# Разработка с использованием сервиса [GitHub](https://www.Github.com/) #

# Содержание
1. [Установка **git**](#1-Установка-git)
2. [Установка git-клиента **TortoiseGit**](#2-Установка-git-клиента-TortoiseGit)
3. [Принципы работы с репозиторием](#3-Принципы-работы-с-репозиторием)
4. [Типовая схема совместной разработки проекта](#4-Типовая-схема-совместной-разработки-проекта)
5. [Создание и оформление **commit**-ов](#5-Создание-и-оформление-commit-ов)
6. [Запросы на внесение изменений (**Pull requests**)](#6-Запросы-на-внесение-изменений-Pull-requests)
7. [Именование документов](#7-Именование-документов)
8. [Использование **Мarkdown**](#8-Использование-Мarkdown)

## 1. Установка **git** ##

Скачать и установить с официального сайта [Git](https://git-scm.com/downloads/).

Git (произносится «гит») — распределённая система управления версиями. Проект был создан Линусом Торвальдсом для управления разработкой ядра Linux, первая версия выпущена 7 апреля 2005 года.

## 2. Установка git-клиента **TortoiseGit** ##

Скачать и установить с официального сайта [TortoiseGit](https://tortoisegit.org/download/).

TortoiseGit — визуальный клиент системы управления исходными кодами программ Git для ОС Microsoft Windows. Реализован как расширение проводника Windows (shell extension). Подрисовывает иконки к файлам, находящимся под управлением Git, для отображения их статуса в Git.

Пользовательский интерфейс сделан на основе TortoiseSVN, поэтому практически полностью совпадает с ним, за исключением возможностей, специфичных для Git.

## 3. Принципы работы с репозиторием ##

Прежде чем начать работу с репозиторием, необходимо сделать его собственное ответвление (fork - произносится «форк»). Для этого необходимо нажать кнопку `Fork` в правом верхнем углу экрана:

![Repository fork](workflow_images/fork.png)

Если появилось окно с выбором организации, то следует выбрать свой профиль.

После этого клонируем собственное ответвление (fork) репозитория:

![Clone repository](workflow_images/clone.png)

Для этого используем контекстное меню (длительное нажатие правой клавишей мыши) для требуемого каталога (рекомендуется использовать путь `"p:\savushkin-r-d\"`), далее выбираем пункт `"Git Clone"`:

![Clone repository](workflow_images/tgit_cmenu_clone.png)

Задаем параметры клонирования:

```sh
URL:        https://github.com/savushkin-r-d/hello-tortoisegit.git
Directory:  P:/savushkin-r-d/hello-tortoisegit/
```

в диалоговом окне:

![Clone repository](workflow_images/tgit_window_clone.png)

Далее нажимаем кнопку `OK` и наблюдаем за ходом операции:

![Clone repository](workflow_images/tgit_window_clone_res_OK.png)

После успешного завершения соответствующий каталог будет содержать репозиторий git.

Чтобы удобно было работать, сразу стоит сделать себе ветку `dev` для работы (также используя контекстное меню):

![Clone repository](workflow_images/tgit_menu_branch.png)

Задаем название ветви, комментарий и указываем, что хотим далее работать с ней (активная галочка `"Switch to new branch"`):

![Clone repository](workflow_images/tgit_window_branch.png)

Теперь можно работать с версией в своей ветке `dev`. **Настоятельно рекомендуется использовать ветку для разработки, а не `master`**.

Добавим наш основной репозиторий, чтобы с него можно было обновляться (более [подробно](https://git-scm.com/book/ru/v1/Основы-Git-Работа-с-удалёнными-репозиториями) про команды):

![Clone repository](workflow_images/tgit_menu_settings.png)

Нажимаем OK для окна с описанием подхода для хранения настроек:

![Clone repository](workflow_images/tgit_window_conf_info.png)

Далее добавляем основной репозиторий. Задаем имя и путь для **основного** репозитория:

```sh
Remote: upstream
URL:    https://github.com/savushkin-r-d/hello-tortoisegit.git
```

для соответствующих полей и нажимаем кнопку `Add New/Save`:

![Clone repository](workflow_images/tgit_window_remotes.png)

и соглашаемся отключить обновление данного репозитория (нажимаем кнопку `"Да"`). Также отменяем получение ветвей добавленного репозитория:

![Clone repository](workflow_images/tgit_window_fetch_remotes.png)

(нажимаем кнопку `"Нет"`).

**Важно:** используйте следующие имена для `remote` ссылок:
- `upstream` - основной репозиторий (центральный), на нем всегда стабильная версия в `master`;
- `origin` - ваш `fork` основного репозитория.

Разделение на `upstream` и `origin` позволяет вам не бояться "сломать" что-либо в основном репозитории. Так как вся ваша работа будет происходить с `fork`-ом.

## 4. Типовая схема совместной разработки проекта ##

Типовая схема совместной работы состоит из следующих этапов:

1. Обновление текущей версии до актуального состояния
2. Внесение изменений
3. Фиксация изменений (*commit*) в своем репозитории
4. Создание запроса на внесение изменений (*Pull request*) в основной репозиторий

### 1. Обновление текущей версии до актуального состояния ###

Далее будет ряд команд, которые позволят получать обновления и работать с основным репозиторием. Для их выполнения необходимо через контекстное меню для каталога репозитория вызвать консоль git:

![Clone repository](workflow_images/gitbash_cmenu.png)

Отобразится окно консоли для текущего репозитория:

![Clone repository](workflow_images/gitbash_window_main.png)

```sh

git checkout master        # переключаемся на ветку master
git remote update          # обновляем все remote
git rebase upstream/master # переносим в наш локальный мастер все изменения
git push origin master     # пушим в наш форк свежий master
git checkout dev           # переключаемся на нашу рабочую ветку
git rebase master          # переносим изменения из мастера в нашу ветку

```
Результат выполнения данных команд:

![Clone repository](workflow_images/gitbash_window_update_res.png)

Для переноса изменений мы используем `rebase` - это позволяет сделать историю изменений легкой для чтения (более подробно можно почитать [тут](https://git-scm.com/book/ru/v1/Ветвление-в-Git-Перемещение) или [тут](https://habrahabr.ru/post/161009/)). Если интересно чем это лучше `merge` то можно почитать эту [статью](https://www.atlassian.com/git/tutorials/merging-vs-rebasing).

### 2. Внесение изменений ###

Используя редактор (рекомендуется использовать [**Visual Studio Code**](https://code.visualstudio.com/)) вносим изменения в файлы репозитория.

### 3. Фиксация изменений (*commit*) в своем репозитории ###

Вызываем через контекстное меню команду `"Git Commit"`:

![Clone repository](workflow_images/tgit_cmenu_commit.png)

Далее в окне фиксации изменений заполняем комментарий, проверяем корректность вносимых изменений для списка изменяемых файлов и нажимаем кнопку `"Commit"`:

![Clone repository](workflow_images/tgit_window_commit.png)

Отображается окно с результатами выполнения операции, далее фиксируем их в своем ответвленном репозитории (fork) - кнопка `"Push"`:

![Clone repository](workflow_images/tgit_window_commit_res.png)

В появившемся окне проверяем корректность параметров:

```sh
Ref
Local:  dev
Remote: dev

Destination
Remote: origin
```
(из локальной ветви `dev` переносим изменения в удаленный репозиторий на сервер Github):

![Clone repository](workflow_images/tgit_window_push.png)

Нажимаем `"ОК"` и получаем результат выполнения данной операции:

![Clone repository](workflow_images/tgit_window_push_res.png)

Далее, если все необходимые изменения внесены, можно создать запрос на внесение изменений (*Pull request*) для того, чтобы данные изменения попали в основной (*upstream*) репозиторий.

### 4. Создание запроса на внесение изменений (*Pull request*) в основной репозиторий ###

После фиксации изменений (смотри предыдущий рисунок) переходим по активной ссылке на страницу Github для ветви `dev` после последних фиксаций:

![Clone repository](workflow_images/tgit_window_push_res_link.png)

В браузере отображается следующая страница, для создания запроса на внесение изменений нажимаем соответствующую кнопку:

![Clone repository](workflow_images/gihub_window_compare_and_pr.png)

Далее отображается страница с параметрами. Необходимо заполнить заголовок запроса, выбрать рецензентов, указать ответственного, добавить поясняющие метки. Также на данной странице проверяются изменения, которые предлагает данный запрос и другая дополнительная информация:

![Clone repository](workflow_images/gihub_window_pr_details.png)

После заполнения всех полей нажимаем на кнопку `"Create pull request"` для создания запроса. Созданный запрос будет отображаться на соответствующей вкладке `"Pull requests"`.

После принятия запроса необходимо обновить свои локальные ветви (см. пункт [Обновление текущей версии до последнего состояния](#1.-Обновление-текущей-версии-до-актуального-состояния).

## 5. Создание и оформление **commit**-ов ##

Каждый `commit` в репозиторий должен быть атомарным и иметь комментарий. Атомарность коммита заключается в том, что в нем находятся изменения в рамках одной задачи. Например: не стоит делать в одном коммите две такие вещи - переименование термина `x` в термин `y`; удаление ненужных файлов.

Стоит из этого сделать два отдельных коммита:
- переименование термина `x` в термин `y`;
- удаление ненужных файлов.

Каждый коммит НЕ должен приводить систему в "сломанное" состояние. После каждого из них она должна работать.

Чтобы упростить навигацию по истории к коммитам необходимо приписывать метки:
```
[метка] Содержание коммита (#issue)
[метка1][метка2] Содержание коммита (#issue)
```

Возможные варианты меток:
- `fix` - когда были исправления в имеющихся исходниках;
- `test` - добавление и изменения в unit-тестах;
- `doc` - изменения в документации;
- `img` - изменения в фотографиях;
- `config` - изменения в конфигурационных файлах и файлах поддержки репозитория (например: `.gitignore`);
- `review` - изменения по комментариям после review.

Например:
- исправили ошибки в поясняющей картинке, тогда коммит выглядит так:
```
[img][fix] Исправлена ошибка в изображении (#38)  // где #38 ссылка на issue
```
- добавили новые файлы и тесты к ним:
```
[img][test] Добавлено описание формата X
```

Таким образом разработчик, глядя на историю будет понимать, что меняется и где.

## 6. Запросы на внесение изменений (**Pull requests**) ##

[Официальная документация](https://help.github.com/articles/creating-a-pull-request) по созданию Pull request.

К *pull requests* применяются следующие правила:
- создается из своей ветки на ветку `master` в основном репозитории;
- автор НЕ имеет права делать `merge` своему *merge request*;
- *pull request* должен быть просмотрен как минимум 2-мя людьми;
- если имеются автоматические тесты, то мержить *pull request* с НЕ работающими автоматическими тестами **строго запрещено**;
- просматривать *pull request* могут все желающие и высказывать свое мнение по нему или отдельным его частям;
- *pull request* принимается, когда все кто участвует в дискуссии пришли к "общему знаменателю".

Рецензия:
- для написания комментариев к исходникам в *pull request*, необходимо перейти на вкладку `Changes` и добавлять комментарии к необходимым строкам:

![Comment PR](workflow_images/comment_pr.png);
- если ревьювер считает что *merge request* можно мержить и нет необходимых правок, то он делает `Approve`. Если же требуются изменения, то `Request changes`:

![Approve PR](workflow_images/approve.png)

## 7. Именование документов ##

Все документы (файлы) должны находится в каталоге с кратким точным названием (на английском языке), отражающее содержимое документа. Примеры названий каталогов:
- Description
- Manual
- Scheme
- Report

Непосредственно документы должны иметь название **readme** и расширение **.md** (используется язык разметки **Мarkdown**).

Возможно также использование других необходимых названий.

## 8. Использование **Мarkdown** ##

Данный облегчённый язык разметки повсеместно используется (для написания документации - *.md файла, комментариев и т.д.). Его подробное описание находится [здесь](https://help.github.com/articles/about-writing-and-formatting-on-github/).
